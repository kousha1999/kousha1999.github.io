# Exploring Android Exploitation: A Journey into Stack Overflow Vulnerability

My journey into Android exploitation at the binary level started with a deep passion for the subject. I was determined to simplify the process as much as possible, but it turned out to be quite challenging. In this post, you'll learn various aspects of Android exploitation, including:

- How to use the NDK to write an application.
- How to create a vulnerable lab environment for demonstrating Stack Overflow vulnerabilities.
- How to exploit Stack Overflow in Android binaries.
- A deep dive into the capabilities of Frida!

I conducted all the steps in this post on an x86 Android emulator (Genymotion).

### Why Frida?

You might wonder why I used Frida. There were two main reasons:

1. **Passion**: I absolutely love working with Frida!
2. **Practicality**: I couldn't find another way to send my binary data for overriding the EIP.

I hope you find this content innovative and insightful.
<p align="center">
<img src="https://user-images.githubusercontent.com/36133745/164783235-d8df38a6-e0f3-4e68-9f64-57fa21b98435.gif">
</p>

## Creating the Vulnerable Application

### Implementing Graphical User Interface
The first step in creating our vulnerable application is to edit the style of the `MainActivity`. The goal here is to set up an interface that allows us to input data for buffer exploitation and includes a button to submit the value.
![activity_main_xml](https://github.com/user-attachments/assets/a6e17ddd-71e1-4fb2-b1aa-8ec1252fc332)

Below is the XML code for `activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity">

    <EditText
        android:id="@+id/user_input"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Enter input" />

    <Button
        android:id="@+id/exploit_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Exploit" />

    <TextView
        android:id="@+id/result_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Result will be shown here" />
</LinearLayout>
```

### Implementing Vulnerable Native C++ Code

To introduce a vulnerability, we'll use native C++ code that is susceptible to a stack overflow.

![native_lib_cpp](https://github.com/user-attachments/assets/69b9517a-5000-4f8c-bb64-0d96d2f7908e)

Below, I've defined three functions, starting with the `main` function. This function simply returns the user input value.

Here's the C++ code for the main function:

```cpp
extern "C" JNIEXPORT jstring JNICALL
Java_com_example_myapplication_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject,
        jstring input) {
    const char* inputCStr = env->GetStringUTFChars(input, nullptr);
    kousha(inputCStr);
    env->ReleaseStringUTFChars(input, inputCStr);
    return env->NewStringUTF(inputCStr);
}
```

The second function in our vulnerable native C++ code is `kousha`. This function is called by `Java_com_example_myapplication_MainActivity_stringFromJNI` and is responsible for copying the user input characters one by one into a fixed-size buffer. 

Below is the C++ code for the `kousha` function:

```cpp
int kousha(const char* inputCStr) {
    char buffer[10];
    const char *p1 = inputCStr;
    char *p2 = buffer;
    while (1) {
        *p2 = *p1;
        if (*p1 == 0) {
            break;
        }
        p1 = p1 + 1;
        p2 = p2 + 1;
    }
    return 0;
}
```

### Implementing the `getSecret` Function

The final piece of our vulnerable application is the `Java_com_example_myapplication_MainActivity_getSecret` function. The goal of this lab is to exploit the stack overflow and override the EIP register to call this function. When successfully called, this function will log "Yeah!" in the `adb logcat` output.

Before diving into the function itself, don't forget to define the logging macro at the beginning of your C++ file:

```cpp
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
```

Here's the C++ code for the getSecret function:

```cpp
extern "C" JNIEXPORT jstring JNICALL
Java_com_example_myapplication_MainActivity_getSecret(
        JNIEnv* env,
        jobject) {
    std::string hello = "Yeah!";
    LOGI("%s", hello.c_str());
    return env->NewStringUTF(hello.c_str());
}
```

#### Code Explanation:

- **Logging Setup:** The macro `LOGI` is defined to log informational messages to the Android `logcat`. This is essential for seeing the "Yeah!" message in the log output.
- **Function Declaration:** Like the previous functions, this one is declared with `extern "C"` to ensure proper linkage for JNI.
- **Logging the Message:** The function logs the string "Yeah!" to the `adb logcat` using the `LOGI` macro.
- **Returning the String:** Finally, the function returns the "Yeah!" string as a new `jstring` back to the Java layer.

#### Exploit Goal:

The goal of this lab is to craft an exploit that causes the kousha function's stack overflow to override the EIP register, redirecting execution to the getSecret function. When successful, youâ€™ll see "Yeah!" logged in the adb logcat output, confirming that the exploit worked.

#### Full Code for Vulnerable Native C++ Functions

Below is the complete C++ code for the vulnerable native functions used in our Android application. This code includes logging macros, the vulnerable `kousha` function, and the `getSecret` function, which we aim to call via an exploit.

```cpp
#include <jni.h>
#include <string>
#include <android/log.h>

#define LOG_TAG "MyApplication"
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)

int kousha(const char* inputCStr) {
    char buffer[10];
    const char *p1 = inputCStr;
    char *p2 = buffer;
    while (true) {
        *p2 = *p1;
        if (*p1 == 0) {
            break;
        }
        p1 = p1 + 1;
        p2 = p2 + 1;
    }
    return 0;
}

extern "C" JNIEXPORT jstring JNICALL
Java_com_example_myapplication_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject,
        jstring input) {
    const char* inputCStr = env->GetStringUTFChars(input, nullptr);
    kousha(inputCStr);
    env->ReleaseStringUTFChars(input, inputCStr);
    return env->NewStringUTF(inputCStr);
}

extern "C" JNIEXPORT jstring JNICALL
Java_com_example_myapplication_MainActivity_getSecret(
        JNIEnv* env,
        jobject) {
    std::string hello = "Yeah!";
    LOGI("%s", hello.c_str());
    return env->NewStringUTF(hello.c_str());
}
```
### Modifying `CMakeLists.txt` for Security Settings and Library Inclusion

To set up our build environment for the vulnerable application, we need to modify the `CMakeLists.txt` file. This involves disabling the `FORTIFY` security feature and adding the `native-lib` library.

![CMakeLists_txt](https://github.com/user-attachments/assets/8bc58c51-9a81-4629-ac24-e5d57d9410cf)


Here is the updated `CMakeLists.txt` configuration:

```cmake
cmake_minimum_required(VERSION 3.22.1)
project("myapplication")

# Add the native-lib library
add_library(native-lib SHARED
        native-lib.cpp)

# Set compiler flags to disable security features and enable debugging
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-stack-protector -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0 -O0 -g")

# Link the native-lib library with Android and log libraries
target_link_libraries(native-lib
        android
        log)
```

Build and run the project now.

![launch-app](https://github.com/user-attachments/assets/f15687bd-6c25-4472-ab91-039b0c744072)

## Exploiting Stack Overflow

Now it's time to trigger a crash. We'll send an excessive number of characters to cause a buffer overflow and crash the app.
Send the following input to trigger the buffer overflow:
`aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`

![app_crash](https://github.com/user-attachments/assets/e240d3c4-1a1d-4448-8ed9-b0f1d7c38f9f)

Now that we know the application is vulnerable, use the `cyclic` function from the `pwntools` Python framework to determine the amount of data needed to reach and override the `EIP` register.

![python_find_eip](https://github.com/user-attachments/assets/35fd25bf-5704-4ab7-908b-2679e0d6d2fb)

We observed that the fault address is `0x61656161`, which corresponds to the last value of `EIP` when the app crashes.

![find_offset_logcat](https://github.com/user-attachments/assets/c2d26dc4-c997-4cbb-b74e-afd3047fa6fd)

